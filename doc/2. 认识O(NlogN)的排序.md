# 认识O（NlogN）的排序

## 递归

```go
func getMax(arr []int)int{ //获取数组中的最大值
    return process(arr,0,len(arr)-1) //返回数组arr中[L...R]范围上的最大值
}

func process(arr []int,L,R int)int{
    if L==R{
        return arr[L] //arr[L...R]范围上只有一个数，直接返回
    }
    mid:=L+((R-L)>>1) //中点，防止溢出
    leftMax:=process(arr,L,mid) //左部分获得的最大值 
    rightMax:=process(arr,mid+1,R) //右部分获得的最大值
    return max(leftMax,rightMax) //返回左右部分获得的最大值
}

func max[T int|int8|int16|int32|int64|float32|float64](a,b T)T{ //泛型
    if a>b{
        return a
    }else{
        return b
    }
}
```

## 归并排序

1. 整体就是一个简单递归，左边排好序、右边排好序，让其整体有序
2. 让其整体有序的过程里用了外排序方法（拷贝数组到外部，排好序再传回来）
3. 利用master公式来求解时间复杂度
4. 归并排序的实质

时间复杂度O(NlogN)，额外空间复杂度O(N)，稳定排序

```go
func mergeSort(arr []int)[]int{
    if arr==nil||len(arr)<2{
        return arr
    }
    mid:=len(arr)>>1
    return merge(mergeSort(arr[:mid]),mergeSort(arr[mid:]))

}

func merge(leftArr,rightArr []int)[]int{
    res:=[]int{}
    i,j:=0,0
    for i<len(leftArr)&&j<len(rightArr){
        if leftArr[i]<=rightArr[j]{
            res=append(res,leftArr[i])
            i++
        }else{
            res=append(res,rightArr[j])
            j++
        }
    }
    res=append(res,leftArr[i:]...)
    res=append(res,rightArr[j:]...)
    return res
}
```

## 小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
例：[1,3,4,2,5],1左边比1小的数没有，3左边比3小的数为1，4左边比4小的数为1、3，2左边比2小的数，1.
5左边比5小的数1、3、4、2，所以小和为1+1+3+1+1+3+4+2=16

| 元素值      | 1   | 3   | 4   | 2   | 5   |
| -------- | --- | --- | --- | --- | --- |
| 下标       | 0   | 1   | 2   | 3   | 4   |
| 右边有多少个小和 | 4   | 2   | 1   | 1   | 0   |

从第0位开始，1的右边有4个元素比1大，因此有4个小和，总小和包括4*1=4

从第1位开始，3的右边有2个元素比3大，因此有2个小和，总小和包括3*2=6

从第2位开始，4的右边有1个元素比4大，因此有1个小和，总小和包括4*1=4

从第3位开始，2的右边有1个元素比2大，因此有1个小和，总小和包括2*1=2

从第4位开始，5的右边无数据，因此没有小和

把上述结果加起来4+6+4+2=16 即数组的小和

**小和原本是求左边有哪些数比它小，也可以转换思路，计算右边哪些数比它大**

计算右边哪些数比它大，可以用归并的思维。

1 3 4 2 5

左侧：1 3 4

右侧：2 5

对于1 3 4来说

左侧：1 3

右侧：4

对2 5来说

左侧：2

右侧：5



首先看1 3，引入外排序，左侧数（1）比右侧数（3）小，小和为1个1，因为1右边只有一个3。

1 3合并回去，此时*1 3*和4合并，1和4比较，产生1个小和（1个1），3和4比较，产生1个小和（1个3）

此时有序的部分为*1 3 4*，拷贝回原数组。

**就是说，左侧merge为1 3 4的时候，产生了这么多小和**

- 1个1

- 1个1

- 1个3

现在看右侧2 5

左侧是2，右侧是5，产生1个小和（1个2） **只有左侧比右侧小，才产生小和，右侧小的时候不产生任何小和**

最后，1 3 4 和2 5 merge

| 1   | 3   | 4   |
| --- | --- | --- |
| ↑   |     |     |

| 2   | 5   |
| --- | --- |
| ↑   |     |

左侧指针指向1，右侧指针指向2

**此时看右侧有几个数比1大，右侧有两个数比1大，因此产生2个小和（2个1）**

此时指针来到3

| 1   | 3   | 4   |
| --- | --- | --- |
|     | ↑   |     |

| 2   | 5   |
| --- | --- |
|     | ↑   |



右侧有1个数比1大，因此产生1个小和（1个3）

此时指针来到4

| 1   | 3   | 4   |
| --- | --- | --- |
|     |     | ↑   |

| 2   | 5   |
| --- | --- |
|     | ↑   |

右侧有1个数比4大，因此产生1个小和（1个4）

总小和为1+1+3+2+1*2+3+4=16

当出现左组和右组的数相同时，先拷贝右组的数进入merge数组，**只有左侧严格比右侧的数小的时候，才能计算小和，然后左组才能往下走**

```go
func smallSum(arr []int) int { //获取数组中的最大值
    if len(arr) < 2 {
        return 0
    }
    return processSmallSum(arr, 0, len(arr)-1) //返回数组arr中[L...R]范围上的最大值
}

func processSmallSum(arr []int, L, R int) int {
    if L == R {
        return 0 //arr[L...R]范围上只有一个数，直接返回
    }
    mid := L + ((R - L) >> 1) //中点，防止溢出
    return processSmallSum(arr, L, mid) + processSmallSum(arr, mid+1, R) + merge(arr, L, mid, R)
}

func merge(arr []int, L, mid, R int) int { //将arr[L...mid]和arr[mid+1...R]两部分进行排序
    help := make([]int, R-L+1) //辅助数组
    i := 0                    //辅助数组的索引
    p1 := L                //左部分的第一个数的索引
    p2 := mid + 1            //右部分的第一个数的索引
    res := 0                //小和
    for p1 <= mid && p2 <= R { //左右两部分都没有越界
        if arr[p1] < arr[p2] { //左部分的数小于右部分的数
            res += arr[p1] * (R - p2 + 1) //计算小和
            help[i] = arr[p1]               //将左部分的数放入辅助数组中
            i++                           //辅助数组的索引+1
            p1++                           //左部分的索引+1
        } else { //左部分的数大于等于右部分的数
            help[i] = arr[p2] //将右部分的数放入辅助数组中
            i++               //辅助数组的索引+1
            p2++               //右部分的索引+1
        }
    }
    for p1 <= mid { //左部分没有越界
        help[i] = arr[p1] //将左部分剩余的数放入辅助数组中
        i++               //辅助数组的索引+1
        p1++               //左部分的索引+1
    }
    for p2 <= R { //右部分没有越界
        help[i] = arr[p2] //将右部分剩余的数放入辅助数组中
        i++               //辅助数组的索引+1
        p2++               //右部分的索引+1
    }
    // for i := 0; i < len(help); i++ {
    //     arr[L+i] = help[i]
    // }
    copy(arr[L:R+1], help) //将help数组中的值拷贝到arr[L...R]中
    return res
}
```

## 逆序对问题

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，打印所有的逆序对，找出逆序对的数量

例如 [3,2,4,5,0]

逆序对为 

- 3 2

- 3 0

- 2 0

- 4 0

- 5 0

5组逆序对





## 荷兰国旗问题

1. 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O（1），时间复杂度O（N） **注意此时还不要求左右两部分有序**

| 3   | 5   | 6   | 7   | 4   | 3   | 5   | 8   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| ↑   |     |     |     |     |     |     |     |

从左向右遍历数组，num=5

- 当arr[i]<=num时，把当前数arr[i]和小于等于区的下一个数交换，小于等于区右扩，i++

- 当arr[i]>num时，i++

```go
func preDutchFlag(arr []int, num int) {
    less:=-1 //小于等于区域的右边界
    for i:=0;i<len(arr);i++{ //遍历数组
        if arr[i]<=num{ //当前数小于等于num
            arr[i],arr[less+1]=arr[less+1],arr[i] //将当前数与小于等于区域的下一个数交换
            less++ //小于等于区域的右边界+1
        }
    }
    fmt.Println(arr)
}
```



2. 荷兰国旗问题，给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组中间，大于num的数放在数组的右边。要求额外空间复杂度O（1），时间复杂度O(N) **注意此时还不要求左右两部分有序**

| 3   | 5   | 6   | 3   | 4   | 5   | 2   | 6   | 9   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| i   |     |     |     |     |     |     |     |     |     |

- 当arr[i]<num时，arr[i]和小于区下一个交换，小于区右扩，i++

- 当arr[i]==num时，啥都不干，i++

- 当arr[i]>num时，arr[i]和大于区域的前一个做交换，大于区域左扩，**i不变**

```go
func dutchFlag(arr []int, num int) {
    less:=-1 //小于区域的右边界
    more:=len(arr) //大于区域的左边界
    for i:=0;i<more;{ //遍历数组，终止遍历条件为i==more，即当前和大于区重合
        if arr[i]<num{ //当前数小于num
            arr[i],arr[less+1]=arr[less+1],arr[i] //将当前数与小于区域的下一个数交换
            less++ //小于区域的右边界+1
            i++
        }else if arr[i]>num{ //当前数大于num
            arr[i],arr[more-1]=arr[more-1],arr[i] //将当前数与大于区域的前一个数交换
            more-- //大于区域的左边界-1
        }else{
            i++ //当前数等于num，不交换，继续遍历
        }
    }
    fmt.Println(arr)
} 

```

## 快速排序

1. 快速排序1.0版本

整个数组中，用最后一个数num做划分，前面的部分，做到小于等于num的放到左边，大于num的放到右边，**然后把num和大于区域的第一个数做交换**，得到的结果是小于等于num的区域被扩充，且最后一位一定是num。**num来到这个位置，就已经排好了**，然后让num的左侧和右侧重复这个行为。



2. 快速排序2.0版本
